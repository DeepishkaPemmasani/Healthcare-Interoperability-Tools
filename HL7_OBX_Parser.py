# -*- coding: utf-8 -*-
"""Untitled0.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1xwYvCHcmnbOIs0-C0ejQ4sXY47IWEPfX
"""

"""
HL7 V2 OBX Subsegment Parser

This module provides functionality to parse HL7 V2 messages and extract specific
OBX (Observation/Result) subsegments that are commonly needed for healthcare
data processing and validation.

Author: [Your Name]
Created during Health Informatics Internship at MIHIN
"""

import hl7
from typing import Dict, List, Any


def check_obx_subsegments(hl7_message: str) -> Dict[str, List[str]]:
    """
    Check for specific OBX sub-segments in an HL7 message.

    This function parses an HL7 V2 message and extracts specific OBX subsegments:
    - OBX.15.1: Producer's ID (first component of Producer's Reference)
    - OBX.15.2: Producer's Text (second component of Producer's Reference)
    - OBX.23.1: Local Process Control (first component)

    Args:
        hl7_message (str): Raw HL7 V2 message string

    Returns:
        Dict[str, List[str]]: Dictionary containing subsegment names as keys
                             and lists of found values as values

    Raises:
        hl7.ParseException: If the HL7 message cannot be parsed

    Example:
        >>> message = "MSH|^~\\&|SENDING_APP|..."
        >>> results = check_obx_subsegments(message)
        >>> print(results['OBX.15.1'])
        ['TestProducer', 'Lab']
    """

    # Parse the HL7 message
    try:
        parsed_message = hl7.parse(hl7_message)
    except Exception as e:
        raise hl7.ParseException(f"Failed to parse HL7 message: {str(e)}")

    # Initialize results dictionary
    results = {
        'OBX.23.1': [],  # Local Process Control
        'OBX.15.1': [],  # Producer's ID
        'OBX.15.2': []   # Producer's Text
    }

    # Find all OBX segments
    for segment in parsed_message:
        if segment[0].value == 'OBX':
            try:
                # Check OBX.23.1 (Local Process Control)
                # OBX.23 is typically the 24th field (0-indexed as 23)
                if len(segment) > 23 and len(segment[23]) > 0:
                    if hasattr(segment[23][0], 'value'):
                        value = segment[23][0].value
                    else:
                        value = str(segment[23][0])

                    if value:  # Only add non-empty values
                        results['OBX.23.1'].append(value)

                # Check OBX.15.1 (Producer's ID)
                # OBX.15 is the 16th field (0-indexed as 15)
                if len(segment) > 15 and len(segment[15]) > 0:
                    if hasattr(segment[15][0], 'value'):
                        value = segment[15][0].value
                    else:
                        value = str(segment[15][0])

                    if value:  # Only add non-empty values
                        results['OBX.15.1'].append(value)

                # Check OBX.15.2 (Producer's Text)
                # Second component of OBX.15
                if len(segment) > 15 and len(segment[15]) > 1:
                    if hasattr(segment[15][1], 'value'):
                        value = segment[15][1].value
                    else:
                        value = str(segment[15][1])

                    if value:  # Only add non-empty values
                        results['OBX.15.2'].append(value)

            except (IndexError, AttributeError) as e:
                # Continue processing other segments if one fails
                print(f"Warning: Error processing OBX segment: {str(e)}")
                continue

    return results


def print_obx_results(results: Dict[str, List[str]]) -> None:
    """
    Pretty print the results from OBX subsegment parsing.

    Args:
        results (Dict[str, List[str]]): Results from check_obx_subsegments()
    """
    print("\n" + "="*50)
    print("OBX SUBSEGMENT ANALYSIS RESULTS")
    print("="*50)

    for field, values in results.items():
        status = 'Present' if values else 'Not present'
        print(f"\n{field}: {status}")

        if values:
            print(f"  Values found ({len(values)} total):")
            for i, value in enumerate(values, 1):
                print(f"    {i}. {value}")


def validate_obx_requirements(results: Dict[str, List[str]],
                            required_fields: List[str] = None) -> Dict[str, Any]:
    """
    Validate that required OBX subsegments are present.

    Args:
        results (Dict[str, List[str]]): Results from check_obx_subsegments()
        required_fields (List[str], optional): List of required field names.
                                             Defaults to all supported fields.

    Returns:
        Dict[str, Any]: Validation results with status and missing fields
    """
    if required_fields is None:
        required_fields = ['OBX.23.1', 'OBX.15.1', 'OBX.15.2']

    missing_fields = []
    present_fields = []

    for field in required_fields:
        if field in results and results[field]:
            present_fields.append(field)
        else:
            missing_fields.append(field)

    validation_result = {
        'is_valid': len(missing_fields) == 0,
        'present_fields': present_fields,
        'missing_fields': missing_fields,
        'total_required': len(required_fields),
        'total_present': len(present_fields)
    }

    return validation_result


# Example usage and testing
if __name__ == "__main__":
    # Sample HL7 message for testing
    sample_message = """MSH|^~\\&|SENDING_APP|SENDING_FAC|REC_APP|REC_FAC|20230820||ORU^R01|MSG00001|P|2.5.1|
OBX|1|TX|1234||Sample Result^^^|||||||F|||20230820||||TestProducer^ProducerText|||||||||Custom_Process_ID^1|
OBX|2|NM|5678||50|mg||||||F|||20230820||||Lab^Report|||||||||Process_Control^2|"""

    print("Testing HL7 OBX Subsegment Parser")
    print("="*50)

    try:
        # Parse the message
        results = check_obx_subsegments(sample_message)

        # Print results
        print_obx_results(results)

        # Validate results
        validation = validate_obx_requirements(results)
        print(f"\n\nVALIDATION RESULTS:")
        print(f"Valid: {validation['is_valid']}")
        print(f"Present: {validation['total_present']}/{validation['total_required']}")

        if validation['missing_fields']:
            print(f"Missing fields: {', '.join(validation['missing_fields'])}")

    except Exception as e:
        print(f"Error processing HL7 message: {str(e)}")